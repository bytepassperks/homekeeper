╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║              🚀 COPY THIS CODE TO SUPABASE DASHBOARD 🚀                      ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝


STEP 1: Go to Supabase Dashboard
──────────────────────────────────────────────────────────────────────────────
1. Open: https://supabase.com/dashboard/project/eoldzusfrveckbgdszld
2. Click "Edge Functions" in left sidebar
3. Click "+ New Edge Function" button
4. Name it: server
5. Click "Create function"


STEP 2: Replace ALL Code With This
──────────────────────────────────────────────────────────────────────────────

Delete everything in the editor and paste THIS ENTIRE CODE:

═══════════════════════════════════════════════════════════════════════════════
START COPYING FROM HERE ↓↓↓
═══════════════════════════════════════════════════════════════════════════════

import { Hono } from 'npm:hono@4';
import { cors } from 'npm:hono@4/cors';
import { logger } from 'npm:hono@4/logger';
import { createClient } from 'jsr:@supabase/supabase-js@2';

const app = new Hono();

// CORS - Allow all origins
app.use('*', cors({
  origin: '*',
  allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
  exposeHeaders: ['Content-Length'],
  maxAge: 86400,
  credentials: true,
}));

app.use('*', logger());

// Handle OPTIONS preflight
app.options('*', (c) => c.text('', 204));

// KV Store Functions
const kvClient = () => createClient(
  Deno.env.get("SUPABASE_URL")!,
  Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!
);

const kvSet = async (key: string, value: any) => {
  const { error } = await kvClient().from("kv_store_7627b83a").upsert({ key, value });
  if (error) throw new Error(error.message);
};

const kvGet = async (key: string) => {
  const { data, error } = await kvClient().from("kv_store_7627b83a").select("value").eq("key", key).maybeSingle();
  if (error) throw new Error(error.message);
  return data?.value;
};

const kvDel = async (key: string) => {
  const { error } = await kvClient().from("kv_store_7627b83a").delete().eq("key", key);
  if (error) throw new Error(error.message);
};

const kvGetByPrefix = async (prefix: string) => {
  const { data, error } = await kvClient().from("kv_store_7627b83a").select("key, value").like("key", prefix + "%");
  if (error) throw new Error(error.message);
  return data?.map((d) => d.value) ?? [];
};

// Helper functions
const getSupabaseAdmin = () => createClient(
  Deno.env.get('SUPABASE_URL')!,
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
);

const getSupabase = () => createClient(
  Deno.env.get('SUPABASE_URL')!,
  Deno.env.get('SUPABASE_ANON_KEY')!
);

const verifyAuth = async (authHeader: string | null) => {
  if (!authHeader) return { error: 'Unauthorized', userId: null };
  const accessToken = authHeader.split(' ')[1];
  const { data: { user }, error } = await getSupabase().auth.getUser(accessToken);
  if (error || !user?.id) return { error: 'Unauthorized', userId: null };
  return { error: null, userId: user.id };
};

// ========== ROUTES ==========

// Health check
app.get('/make-server-7627b83a/health', (c) => {
  return c.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// Signup
app.post('/make-server-7627b83a/signup', async (c) => {
  try {
    const { email, password, name } = await c.req.json();
    if (!email || !password || !name) {
      return c.json({ error: 'Email, password, and name are required' }, 400);
    }

    const { data, error } = await getSupabaseAdmin().auth.admin.createUser({
      email,
      password,
      user_metadata: { name },
      email_confirm: true
    });

    if (error) {
      console.log(`Registration error: ${error.message}`);
      return c.json({ error: error.message }, 400);
    }

    if (data.user) {
      await kvSet(`user:${data.user.id}:preferences`, {
        userId: data.user.id,
        emailNotifications: true,
        smsNotifications: false,
        reminderDays: 7,
        quietHoursStart: '22:00',
        quietHoursEnd: '08:00',
        currency: 'USD'
      });
    }

    console.log(`User registered: ${email}`);
    return c.json({ success: true, userId: data.user.id });
  } catch (err: any) {
    console.log(`Signup error: ${err.message}`);
    return c.json({ error: 'Registration failed' }, 500);
  }
});

// Create item
app.post('/make-server-7627b83a/items', async (c) => {
  try {
    const { error, userId } = await verifyAuth(c.req.header('Authorization'));
    if (error) return c.json({ error }, 401);

    const itemData = await c.req.json();
    const itemId = crypto.randomUUID();
    const now = new Date().toISOString();

    const item = {
      id: itemId,
      userId,
      ...itemData,
      createdAt: now,
      updatedAt: now
    };

    await kvSet(`user:${userId}:item:${itemId}`, item);

    try {
      const webhookUrl = await kvGet(`user:${userId}:webhook:new-item`);
      if (webhookUrl) {
        fetch(webhookUrl as string, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ item, userId })
        }).catch(() => {});
      }
    } catch (e) {}

    return c.json({ success: true, item });
  } catch (err: any) {
    console.log(`Create item error: ${err.message}`);
    return c.json({ error: 'Failed to create item' }, 500);
  }
});

// Get items
app.get('/make-server-7627b83a/items', async (c) => {
  try {
    const { error, userId } = await verifyAuth(c.req.header('Authorization'));
    if (error) return c.json({ error }, 401);

    const items = await kvGetByPrefix(`user:${userId}:item:`);
    return c.json({ items });
  } catch (err: any) {
    return c.json({ error: 'Failed to fetch items' }, 500);
  }
});

// Update item
app.put('/make-server-7627b83a/items/:itemId', async (c) => {
  try {
    const { error, userId } = await verifyAuth(c.req.header('Authorization'));
    if (error) return c.json({ error }, 401);

    const itemId = c.req.param('itemId');
    const updates = await c.req.json();
    const existingItem = await kvGet(`user:${userId}:item:${itemId}`);
    
    if (!existingItem) return c.json({ error: 'Item not found' }, 404);

    const updatedItem = {
      ...existingItem,
      ...updates,
      id: itemId,
      userId,
      updatedAt: new Date().toISOString()
    };

    await kvSet(`user:${userId}:item:${itemId}`, updatedItem);
    return c.json({ success: true, item: updatedItem });
  } catch (err: any) {
    return c.json({ error: 'Failed to update item' }, 500);
  }
});

// Delete item
app.delete('/make-server-7627b83a/items/:itemId', async (c) => {
  try {
    const { error, userId } = await verifyAuth(c.req.header('Authorization'));
    if (error) return c.json({ error }, 401);

    const itemId = c.req.param('itemId');
    await kvDel(`user:${userId}:item:${itemId}`);
    
    const maintenanceRecords = await kvGetByPrefix(`user:${userId}:maintenance:${itemId}:`);
    for (const record of maintenanceRecords) {
      await kvDel(`user:${userId}:maintenance:${itemId}:${record.id}`);
    }

    return c.json({ success: true });
  } catch (err: any) {
    return c.json({ error: 'Failed to delete item' }, 500);
  }
});

// Log maintenance
app.post('/make-server-7627b83a/maintenance', async (c) => {
  try {
    const { error, userId } = await verifyAuth(c.req.header('Authorization'));
    if (error) return c.json({ error }, 401);

    const { itemId, date, cost, notes, performedBy } = await c.req.json();
    const maintenanceId = crypto.randomUUID();

    const record = {
      id: maintenanceId,
      itemId,
      date,
      cost: cost || 0,
      notes,
      performedBy,
      createdAt: new Date().toISOString()
    };

    await kvSet(`user:${userId}:maintenance:${itemId}:${maintenanceId}`, record);

    const item = await kvGet(`user:${userId}:item:${itemId}`);
    if (item) {
      const maintenanceDate = new Date(date);
      const nextDate = new Date(maintenanceDate);
      nextDate.setDate(nextDate.getDate() + (item.maintenanceInterval || 90));

      await kvSet(`user:${userId}:item:${itemId}`, {
        ...item,
        lastMaintenance: date,
        nextMaintenance: nextDate.toISOString().split('T')[0],
        updatedAt: new Date().toISOString()
      });
    }

    return c.json({ success: true, record });
  } catch (err: any) {
    return c.json({ error: 'Failed to log maintenance' }, 500);
  }
});

// Get maintenance records
app.get('/make-server-7627b83a/maintenance/:itemId', async (c) => {
  try {
    const { error, userId } = await verifyAuth(c.req.header('Authorization'));
    if (error) return c.json({ error }, 401);

    const itemId = c.req.param('itemId');
    const records = await kvGetByPrefix(`user:${userId}:maintenance:${itemId}:`);
    records.sort((a: any, b: any) => new Date(b.date).getTime() - new Date(a.date).getTime());

    return c.json({ records });
  } catch (err: any) {
    return c.json({ error: 'Failed to fetch maintenance records' }, 500);
  }
});

// Get preferences
app.get('/make-server-7627b83a/preferences', async (c) => {
  try {
    const { error, userId } = await verifyAuth(c.req.header('Authorization'));
    if (error) return c.json({ error }, 401);

    let preferences = await kvGet(`user:${userId}:preferences`);
    
    if (!preferences) {
      preferences = {
        userId,
        emailNotifications: true,
        smsNotifications: false,
        reminderDays: 7,
        quietHoursStart: '22:00',
        quietHoursEnd: '08:00',
        currency: 'USD'
      };
    }

    return c.json({ preferences });
  } catch (err: any) {
    return c.json({ error: 'Failed to fetch preferences' }, 500);
  }
});

// Update preferences
app.put('/make-server-7627b83a/preferences', async (c) => {
  try {
    const { error, userId } = await verifyAuth(c.req.header('Authorization'));
    if (error) return c.json({ error }, 401);

    const preferences = await c.req.json();
    await kvSet(`user:${userId}:preferences`, { ...preferences, userId });

    return c.json({ success: true, preferences });
  } catch (err: any) {
    return c.json({ error: 'Failed to update preferences' }, 500);
  }
});

// Webhook: new-item
app.post('/make-server-7627b83a/api/webhook/new-item', async (c) => {
  try {
    const { item, userId } = await c.req.json();
    const logId = crypto.randomUUID();
    await kvSet(`webhook-log:${logId}`, {
      endpoint: '/api/webhook/new-item',
      timestamp: new Date().toISOString(),
      status: 'success',
      message: `New item added: ${item.name}`
    });
    return c.json({ success: true, message: 'Item webhook received' });
  } catch (err: any) {
    return c.json({ error: 'Webhook processing failed' }, 500);
  }
});

// Webhook: maintenance-reminder
app.post('/make-server-7627b83a/api/webhook/maintenance-reminder', async (c) => {
  try {
    const logId = crypto.randomUUID();
    await kvSet(`webhook-log:${logId}`, {
      endpoint: '/api/webhook/maintenance-reminder',
      timestamp: new Date().toISOString(),
      status: 'success',
      message: 'Maintenance reminder check completed'
    });
    return c.json({ success: true, message: 'Maintenance reminders processed' });
  } catch (err: any) {
    return c.json({ error: 'Webhook processing failed' }, 500);
  }
});

// Webhook: warranty-alert
app.post('/make-server-7627b83a/api/webhook/warranty-alert', async (c) => {
  try {
    const logId = crypto.randomUUID();
    await kvSet(`webhook-log:${logId}`, {
      endpoint: '/api/webhook/warranty-alert',
      timestamp: new Date().toISOString(),
      status: 'success',
      message: 'Warranty alert check completed'
    });
    return c.json({ success: true, message: 'Warranty alerts processed' });
  } catch (err: any) {
    return c.json({ error: 'Webhook processing failed' }, 500);
  }
});

// Webhook: find-replacement
app.post('/make-server-7627b83a/api/webhook/find-replacement', async (c) => {
  try {
    const { item } = await c.req.json();
    const replacements = [
      { name: `${item.name} (2025 Model)`, price: item.price * 1.1, source: 'Amazon', url: '#', rating: 4.5 },
      { name: `Similar to ${item.name}`, price: item.price * 0.9, source: 'Flipkart', url: '#', rating: 4.3 }
    ];
    
    const logId = crypto.randomUUID();
    await kvSet(`webhook-log:${logId}`, {
      endpoint: '/api/webhook/find-replacement',
      timestamp: new Date().toISOString(),
      status: 'success',
      message: `Found ${replacements.length} replacement options`
    });
    
    return c.json({ success: true, replacements });
  } catch (err: any) {
    return c.json({ error: 'Webhook processing failed' }, 500);
  }
});

// Webhook: annual-report
app.post('/make-server-7627b83a/api/webhook/annual-report', async (c) => {
  try {
    const logId = crypto.randomUUID();
    await kvSet(`webhook-log:${logId}`, {
      endpoint: '/api/webhook/annual-report',
      timestamp: new Date().toISOString(),
      status: 'success',
      message: 'Annual report generation completed'
    });
    return c.json({ success: true, message: 'Annual report generated' });
  } catch (err: any) {
    return c.json({ error: 'Webhook processing failed' }, 500);
  }
});

// Get webhook logs
app.get('/make-server-7627b83a/webhook-logs', async (c) => {
  try {
    const logs = await kvGetByPrefix('webhook-log:');
    logs.sort((a: any, b: any) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
    return c.json({ logs: logs.slice(0, 20) });
  } catch (err: any) {
    return c.json({ error: 'Failed to fetch logs' }, 500);
  }
});

// Get notifications
app.get('/make-server-7627b83a/notifications', async (c) => {
  try {
    const { error, userId } = await verifyAuth(c.req.header('Authorization'));
    if (error) return c.json({ error }, 401);

    const notifications = await kvGetByPrefix(`user:${userId}:notification:`);
    notifications.sort((a: any, b: any) => 
      new Date(b.sentAt || b.createdAt).getTime() - new Date(a.sentAt || a.createdAt).getTime()
    );

    return c.json({ notifications: notifications.slice(0, 50) });
  } catch (err: any) {
    return c.json({ error: 'Failed to fetch notifications' }, 500);
  }
});

// Start server
Deno.serve(app.fetch);

═══════════════════════════════════════════════════════════════════════════════
STOP COPYING HERE ↑↑↑
═══════════════════════════════════════════════════════════════════════════════


STEP 3: Deploy the Function
──────────────────────────────────────────────────────────────────────────────
1. Click "Save" or "Deploy" button
2. Wait for deployment to complete (usually 10-30 seconds)
3. Look for "Deployment successful" message


STEP 4: Test It Works
──────────────────────────────────────────────────────────────────────────────
Open this URL in your browser:

https://eoldzusfrveckbgdszld.supabase.co/functions/v1/make-server-7627b83a/health

You should see:
{"status":"ok","timestamp":"2025-10-25T..."}


STEP 5: Test Your App
──────────────────────────────────────────────────────────────────────────────
1. Go to: https://homekeeper-jfu0.onrender.com
2. Click "Get Started"
3. Try to register a new account
4. If it works → YOU'RE DONE! ✅
5. If CORS error still appears → Check the troubleshooting below


══════════════════════════════════════════════════════════════════════════════

🚨 TROUBLESHOOTING 🚨

If you still see CORS errors:

1. Make sure you deployed the function (Step 3)
2. Make sure the health check works (Step 4)
3. Check the function URL is exactly:
   https://eoldzusfrveckbgdszld.supabase.co/functions/v1/make-server-7627b83a

4. In Supabase Dashboard → Edge Functions → server
   Check the "Logs" tab for any errors

5. If the function name is different (not "server"), you need to either:
   - Rename it to "server"
   - OR update your frontend code to use the correct name

══════════════════════════════════════════════════════════════════════════════

✅ THAT'S IT!

No GitHub push needed.
No Render redeploy needed.
Just update the Edge Function in Supabase Dashboard.

══════════════════════════════════════════════════════════════════════════════
